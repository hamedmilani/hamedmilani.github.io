<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Player Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 1rem; /* Rounded corners */
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            max-width: 90%; /* Responsive width */
            width: 600px; /* Max width for larger screens */
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            grid-template-rows: repeat(8, minmax(0, 1fr));
            width: 100%; /* Make board responsive */
            max-width: 500px; /* Max width for the board itself */
            aspect-ratio: 1 / 1; /* Keep it square */
            border: 2px solid #4a5568; /* Board border */
            border-radius: 0.5rem;
            overflow: hidden; /* Ensures rounded corners on squares */
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem; /* Piece size */
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            transition: background-color 0.2s ease;
        }

        .light {
            background-color: #f0d9b5; /* Light square color */
        }

        .dark {
            background-color: #b58863; /* Dark square color */
        }

        /* Dedicated classes for piece colors */
        .piece-white {
            color: #f8f8f8; /* Very light color for white pieces */
        }

        .piece-black {
            color: #2c2c2c; /* Very dark color for black pieces */
        }

        .selected {
            background-color: #6ee7b7; /* Green for selected piece */
        }

        .possible-move {
            background-color: #a7f3d0; /* Lighter green for possible moves */
            position: relative;
        }

        .possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .possible-move.capture::after {
            width: 90%;
            height: 90%;
            border: 4px solid rgba(0, 0, 0, 0.2);
            background: none;
            border-radius: 0; /* Square border for capture */
        }

        .king-in-checkmate {
            background-color: #ef4444 !important; /* Red for king in checkmate */
        }

        .status-display {
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            min-height: 2rem; /* To prevent layout shift */
        }

        .reset-button {
            background-color: #4299e1; /* Blue */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .reset-button:hover {
            background-color: #3182ce; /* Darker blue on hover */
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-5 bg-gray-900 text-gray-200">
    <div class="game-container bg-gray-800 rounded-2xl p-6 shadow-xl flex flex-col items-center gap-6 max-w-lg w-full">
        <h1 class="text-3xl font-bold text-blue-400 mb-4">Two-Player Chess</h1>
        <div id="status" class="status-display text-lg font-semibold text-center text-gray-100">White to move</div>
        <div id="chessboard" class="chessboard">
            </div>
        <button id="resetButton" class="reset-button">Reset Game</button>
    </div>

    <script>
        // Initialize Firebase variables (will be populated by the Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? initialAuthToken : null;

        // Chess board and game state
        let board = [];
        let currentPlayer = 'white'; // 'white' or 'black'
        let selectedPiece = null; // { row, col, piece }
        let possibleMoves = [];
        let isGameOver = false;

        // Piece Unicode characters
        const PIECES = {
            'wp': '♙', 'wr': '♖', 'wn': '♘', 'wb': '♗', 'wq': '♕', 'wk': '♔',
            'bp': '♟', 'br': '♜', 'bn': '♞', 'bb': '♝', 'bq': '♛', 'bk': '♚'
        };

        // Initialize Tone.js for sounds
        // Move sound (using a soft wooden click sound)
        const moveSound = new Tone.Player("https://freesound.org/data/previews/171/171104_71257-lq.mp3").toDestination();

        // Capture sound (using a sharper piece placement sound)
        const captureSound = new Tone.Player("https://freesound.org/data/previews/243/243020_1838974-lq.mp3").toDestination();

        // Check sound (using a synthesized tone)
        const checkSound = new Tone.Synth().toDestination(); 

        // Mate sound (for sequencing two notes, keeping PolySynth for multiple notes)
        const mateSound = new Tone.PolySynth().toDestination(); 

        // Function to play sounds
        function playSound(type) {
            // Ensure audio context is running before playing sounds
            if (Tone.context.state !== 'running') {
                Tone.start();
            }

            switch (type) {
                case 'move':
                    // Check if the player is loaded before starting
                    if (moveSound.loaded) {
                        moveSound.start();
                    } else {
                        // Optionally, try to load and then play if not loaded (for robustness)
                        moveSound.load("https://freesound.org/data/previews/171/171104_71257-lq.mp3").then(() => {
                            moveSound.start();
                        });
                    }
                    break;
                case 'capture':
                    // Check if the player is loaded before starting
                    if (captureSound.loaded) {
                        captureSound.start();
                    } else {
                        // Optionally, try to load and then play if not loaded (for robustness)
                        captureSound.load("https://freesound.org/data/previews/243/243020_1838974-lq.mp3").then(() => {
                            captureSound.start();
                        });
                    }
                    break;
                case 'check':
                    checkSound.triggerAttackRelease("G4", "8n"); // Current check sound
                    break;
                case 'mate':
                    // "dan dannn" effect with two notes
                    mateSound.triggerAttackRelease("C4", "8n"); // First note "dan"
                    setTimeout(() => {
                        mateSound.triggerAttackRelease("G4", "4n"); // Second note "dannn"
                    }, 150); // Delay of 150 milliseconds
                    break;
            }
        }

        // --- Game Initialization ---
        function initializeBoard() {
            isGameOver = false;
            currentPlayer = 'white';
            selectedPiece = null;
            possibleMoves = [];

            board = [
                ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
                ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
            ];
            updateStatus(`${capitalize(currentPlayer)} to move`);
            drawBoard();
        }

        // --- Board Drawing ---
        function drawBoard() {
            const chessboardDiv = document.getElementById('chessboard');
            chessboardDiv.innerHTML = ''; // Clear existing board

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.dataset.row = r;
                    square.dataset.col = c;

                    // Alternate square colors
                    if ((r + c) % 2 === 0) {
                        square.classList.add('light');
                    } else {
                        square.classList.add('dark');
                    }

                    const piece = board[r][c];
                    if (piece) {
                        square.textContent = PIECES[piece];
                        // Apply specific piece color classes
                        const pieceColorClass = piece[0] === 'w' ? 'piece-white' : 'piece-black';
                        square.classList.add(pieceColorClass);
                    }

                    // Add click listener to each square
                    square.addEventListener('click', handleSquareClick);

                    chessboardDiv.appendChild(square);
                }
            }

            // Apply highlights if any
            if (selectedPiece) {
                const { row, col } = selectedPiece;
                const selectedSquare = document.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                if (selectedSquare) {
                    selectedSquare.classList.add('selected');
                }
            }
            possibleMoves.forEach(move => {
                const [r, c] = move;
                const targetSquare = document.querySelector(`.square[data-row="${r}"][data-col="${c}"]`);
                if (targetSquare) {
                    targetSquare.classList.add('possible-move');
                    if (board[r][c]) { // If there's a piece, it's a capture move
                        targetSquare.classList.add('capture');
                    }
                }
            });

            // Highlight king if in check
            const kingColor = currentPlayer === 'white' ? 'wk' : 'bk';
            const kingPosition = findKing(board, kingColor);
            if (kingPosition && isKingInCheck(board, currentPlayer)) {
                const [kingR, kingC] = kingPosition;
                const kingSquare = document.querySelector(`.square[data-row="${kingR}"][data-col="${kingC}"]`);
                if (kingSquare) {
                    kingSquare.classList.add('king-in-checkmate'); // Using this class for check too
                }
            }
        }

        // --- Event Handling ---
        function handleSquareClick(event) {
            if (isGameOver) return;

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            const clickedPiece = board[row][col];

            // If a piece is already selected
            if (selectedPiece) {
                // Check if the clicked square is a valid possible move
                const moveIndex = possibleMoves.findIndex(move => move[0] === row && move[1] === col);
                if (moveIndex !== -1) {
                    // Valid move: make the move
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    selectedPiece = null;
                    possibleMoves = [];
                    drawBoard(); // Redraw after move
                } else {
                    // Clicked on another square, deselect or select new piece
                    selectedPiece = null;
                    possibleMoves = [];
                    drawBoard(); // Clear highlights
                    // If clicked on a piece of the current player, select it
                    if (clickedPiece && clickedPiece[0] === currentPlayer[0]) {
                        selectPiece(row, col, clickedPiece);
                    }
                }
            } else {
                // No piece selected, try to select one
                if (clickedPiece && clickedPiece[0] === currentPlayer[0]) {
                    selectPiece(row, col, clickedPiece);
                }
            }
        }

        function selectPiece(row, col, piece) {
            selectedPiece = { row, col, piece };
            possibleMoves = getLegalMoves(row, col, piece);
            drawBoard(); // Redraw to highlight selected piece and possible moves
        }

        // --- Game Logic ---

        // Function to get all pseudo-legal moves for a piece (doesn't check for king safety)
        function getPseudoLegalMoves(row, col, piece) {
            const moves = [];
            const color = piece[0];
            const type = piece[1];

            switch (type) {
                case 'p': // Pawn
                    const direction = (color === 'w') ? -1 : 1;
                    // Single move
                    if (board[row + direction] && !board[row + direction][col]) {
                        moves.push([row + direction, col]);
                    }
                    // Double move from start
                    if (((color === 'w' && row === 6) || (color === 'b' && row === 1)) &&
                        !board[row + direction][col] && board[row + 2 * direction] && !board[row + 2 * direction][col]) {
                        moves.push([row + 2 * direction, col]);
                    }
                    // Captures
                    if (board[row + direction]) { // Ensure row exists
                        if (col - 1 >= 0 && board[row + direction][col - 1] && board[row + direction][col - 1][0] !== color) {
                            moves.push([row + direction, col - 1]);
                        }
                        if (col + 1 < 8 && board[row + direction][col + 1] && board[row + direction][col + 1][0] !== color) {
                            moves.push([row + direction, col + 1]);
                        }
                    }
                    break;
                case 'r': // Rook
                    // Horizontal and Vertical
                    for (let i = row + 1; i < 8; i++) { if (!addMoveIfValid(moves, i, col, color)) break; }
                    for (let i = row - 1; i >= 0; i--) { if (!addMoveIfValid(moves, i, col, color)) break; }
                    for (let i = col + 1; i < 8; i++) { if (!addMoveIfValid(moves, row, i, color)) break; }
                    for (let i = col - 1; i >= 0; i--) { if (!addMoveIfValid(moves, row, i, color)) break; }
                    break;
                case 'n': // Knight
                    const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    knightMoves.forEach(([dr, dc]) => addMoveIfValid(moves, row + dr, col + dc, color, true));
                    break;
                case 'b': // Bishop
                    // Diagonals
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row + i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row + i, col - i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row - i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row - i, col - i, color)) break; }
                    break;
                case 'q': // Queen
                    // Combines Rook and Bishop moves
                    for (let i = row + 1; i < 8; i++) { if (!addMoveIfValid(moves, i, col, color)) break; }
                    for (let i = row - 1; i >= 0; i--) { if (!addMoveIfValid(moves, i, col, color)) break; }
                    for (let i = col + 1; i < 8; i++) { if (!addMoveIfValid(moves, row, i, color)) break; }
                    for (let i = col - 1; i >= 0; i--) { if (!addMoveIfValid(moves, row, i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row + i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row + i, col - i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row - i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row - i, col - i, color)) break; }
                    break;
                case 'k': // King
                    const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                    kingMoves.forEach(([dr, dc]) => addMoveIfValid(moves, row + dr, col + dc, color, true));
                    break;
            }
            return moves;
        }

        // Helper for sliding pieces (Rook, Bishop, Queen)
        function addMoveIfValid(moves, r, c, color, isSingleMove = false) {
            if (r < 0 || r >= 8 || c < 0 || c >= 8) return false; // Out of bounds

            const targetPiece = board[r][c];
            if (targetPiece && targetPiece[0] === color) {
                return false; // Cannot move to square occupied by own piece
            }
            moves.push([r, c]);
            if (targetPiece && targetPiece[0] !== color) {
                return false; // Captured opponent's piece, stop sliding
            }
            return true; // Continue sliding
        }

        // Function to find the king's position
        function findKing(currentBoard, kingPiece) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === kingPiece) {
                        return [r, c];
                    }
                }
            }
            return null;
        }

        // Function to check if a king is in check on a given board state
        function isKingInCheck(currentBoard, kingColor) {
            const kingPiece = kingColor === 'white' ? 'wk' : 'bk';
            const opponentColor = kingColor === 'white' ? 'b' : 'w';
            const kingPos = findKing(currentBoard, kingPiece);

            if (!kingPos) return false; // Should not happen in a valid game

            const [kingR, kingC] = kingPos;

            // Iterate through all opponent's pieces and check if any can attack the king
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece[0] === opponentColor) {
                        const opponentPseudoMoves = getPseudoLegalMovesForCheck(currentBoard, r, c, piece);
                        for (const move of opponentPseudoMoves) {
                            if (move[0] === kingR && move[1] === kingC) {
                                return true; // King is in check
                            }
                        }
                    }
                }
            }
            return false;
        }

        // A specialized getPseudoLegalMoves that operates on a given board (for check calculations)
        function getPseudoLegalMovesForCheck(currentBoard, row, col, piece) {
            const moves = [];
            const color = piece[0];
            const type = piece[1];

            // Helper for sliding pieces (Rook, Bishop, Queen) for check calculation
            function addMoveIfValidForCheck(movesArr, r, c, pieceColor, isSingleMove = false) {
                if (r < 0 || r >= 8 || c < 0 || c >= 8) return false; // Out of bounds

                const targetPiece = currentBoard[r][c];
                if (targetPiece && targetPiece[0] === pieceColor) {
                    return false; // Cannot move to square occupied by own piece
                }
                movesArr.push([r, c]);
                if (targetPiece && targetPiece[0] !== pieceColor) {
                    return false; // Captured opponent's piece, stop sliding
                }
                return true; // Continue sliding
            }

            switch (type) {
                case 'p': // Pawn
                    const direction = (color === 'w') ? -1 : 1;
                    // Only consider captures for check detection
                    if (currentBoard[row + direction]) {
                        if (col - 1 >= 0 && currentBoard[row + direction][col - 1] && currentBoard[row + direction][col - 1][0] !== color) {
                            moves.push([row + direction, col - 1]);
                        }
                        if (col + 1 < 8 && currentBoard[row + direction][col + 1] && currentBoard[row + direction][col + 1][0] !== color) {
                            moves.push([row + direction, col + 1]);
                        }
                    }
                    break;
                case 'r': // Rook
                    for (let i = row + 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, i, col, color)) break; }
                    for (let i = row - 1; i >= 0; i--) { if (!addMoveIfValidForCheck(moves, i, col, color)) break; }
                    for (let i = col + 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row, i, color)) break; }
                    for (let i = col - 1; i >= 0; i--) { if (!addMoveIfValidForCheck(moves, row, i, color)) break; }
                    break;
                case 'n': // Knight
                    const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    knightMoves.forEach(([dr, dc]) => addMoveIfValidForCheck(moves, row + dr, col + dc, color, true));
                    break;
                case 'b': // Bishop
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row + i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row + i, col - i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row - i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row - i, col - i, color)) break; }
                    break;
                case 'q': // Queen
                    for (let i = row + 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, i, col, color)) break; }
                    for (let i = row - 1; i >= 0; i--) { if (!addMoveIfValidForCheck(moves, i, col, color)) break; }
                    for (let i = col + 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row, i, color)) break; }
                    for (let i = col - 1; i >= 0; i--) { if (!addMoveIfValidForCheck(moves, row, i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row + i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row + i, col - i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row - i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row - i, col - i, color)) break; }
                    break;
                case 'k': // King
                    const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                    kingMoves.forEach(([dr, dc]) => addMoveIfValidForCheck(moves, row + dr, col + dc, color, true));
                    break;
            }
            return moves;
        }


        // Function to get all legal moves (considers king safety)
        function getLegalMoves(startRow, startCol, piece) {
            const pseudoLegalMoves = getPseudoLegalMoves(startRow, startCol, piece);
            const legalMoves = [];

            for (const [endR, endC] of pseudoLegalMoves) {
                // Simulate the move
                const tempBoard = JSON.parse(JSON.stringify(board)); // Deep copy
                const capturedPiece = tempBoard[endR][endC];
                tempBoard[endR][endC] = tempBoard[startRow][startCol];
                tempBoard[startRow][startCol] = null;

                // Check if king is in check after the move
                if (!isKingInCheck(tempBoard, currentPlayer)) {
                    legalMoves.push([endR, endC]);
                }
            }
            return legalMoves;
        }

        // Function to execute a move
        function makeMove(startRow, startCol, endRow, endCol) {
            const pieceToMove = board[startRow][startCol];
            const capturedPiece = board[endRow][endCol];

            board[endRow][endCol] = pieceToMove;
            board[startRow][startCol] = null;

            if (capturedPiece) {
                playSound('capture');
            } else {
                playSound('move');
            }

            // Check for pawn promotion (simple: always to queen)
            if (pieceToMove[1] === 'p' && ((currentPlayer === 'white' && endRow === 0) || (currentPlayer === 'black' && endRow === 7))) {
                board[endRow][endCol] = currentPlayer === 'white' ? 'wq' : 'bq';
            }

            // Switch turns
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

            // Check game status after move
            checkGameStatus();
        }

        function checkGameStatus() {
            const playerWhoseTurnItIs = currentPlayer;
            const playerWhoJustMoved = currentPlayer === 'white' ? 'black' : 'white';

            const isPlayerWhoseTurnItIsInCheck = isKingInCheck(board, playerWhoseTurnItIs);

            if (isPlayerWhoseTurnItIsInCheck) {
                playSound('check');
                let hasLegalMoves = false;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece[0] === playerWhoseTurnItIs[0]) {
                            if (getLegalMoves(r, c, piece).length > 0) {
                                hasLegalMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasLegalMoves) break;
                }

                if (!hasLegalMoves) {
                    isGameOver = true;
                    playSound('mate');
                    updateStatus(`${capitalize(playerWhoseTurnItIs)} is checkmated! ${capitalize(playerWhoJustMoved)} wins!`);
                    const kingPieceInCheck = playerWhoseTurnItIs === 'white' ? 'wk' : 'bk';
                    const kingPosition = findKing(board, kingPieceInCheck);
                    if (kingPosition) {
                        const [kingR, kingC] = kingPosition;
                        const kingSquare = document.querySelector(`.square[data-row="${kingR}"][data-col="${kingC}"]`);
                        if (kingSquare) {
                            kingSquare.classList.add('king-in-checkmate');
                        }
                    }
                    return;
                } else {
                    updateStatus(`${capitalize(playerWhoseTurnItIs)} is in check! ${capitalize(playerWhoseTurnItIs)} to move.`);
                }
            } else {
                let hasLegalMoves = false;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece[0] === playerWhoseTurnItIs[0]) {
                            if (getLegalMoves(r, c, piece).length > 0) {
                                hasLegalMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasLegalMoves) break;
                }

                if (!hasLegalMoves) {
                    isGameOver = true;
                    updateStatus(`Stalemate! It's a draw.`);
                    return;
                }

                updateStatus(`${capitalize(playerWhoseTurnItIs)} to move`);
            }
        }

        // --- UI Helpers ---
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // --- Reset Button ---
        document.getElementById('resetButton').addEventListener('click', initializeBoard);

        // --- Initial Setup ---
        window.onload = function() {
            // Start Tone.js audio context on first user interaction
            document.documentElement.addEventListener('mousedown', () => {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
            }, { once: true }); // Only run once

            initializeBoard();
        };

    </script>
</body>
</html>
