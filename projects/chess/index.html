<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two-Player Chess</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 1rem; /* Rounded corners */
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            max-width: 90%; /* Responsive width */
            width: 700px; /* Increased max width for double board */
        }

        .board-wrapper {
            display: flex;
            gap: 20px;
            justify-content: center;
            width: 100%;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, minmax(0, 1fr));
            grid-template-rows: repeat(8, minmax(0, 1fr));
            width: 100%; /* Make board responsive */
            max-width: 300px; /* Max width for the board itself */
            aspect-ratio: 1 / 1; /* Keep it square */
            border: 2px solid #4a5568; /* Board border */
            border-radius: 0.5rem;
            overflow: hidden; /* Ensures rounded corners on squares */
            transition: transform 0.3s ease-in-out; /* For rotation effect */
        }

        /* Styles for double board setup */
        .double-board-container {
            display: flex;
            gap: 20px;
        }

        .rotated-board {
            transform: rotate(180deg);
        }
        .rotated-board .square {
            transform: rotate(180deg); /* Rotate pieces back */
        }


        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem; /* Piece size */
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            transition: background-color 0.2s ease;
        }

        .light {
            background-color: #f0d9b5; /* Light square color */
        }

        .dark {
            background-color: #b58863; /* Dark square color */
        }

        /* Dedicated classes for piece colors */
        .piece-white {
            color: #f8f8f8; /* Very light color for white pieces */
        }

        .piece-black {
            color: #2c2c2c; /* Very dark color for black pieces */
        }

        .selected {
            background-color: #6ee7b7; /* Green for selected piece */
        }

        .possible-move {
            background-color: #a7f3d0; /* Lighter green for possible moves */
            position: relative;
        }

        .possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .possible-move.capture::after {
            width: 90%;
            height: 90%;
            border: 4px solid rgba(0, 0, 0, 0.2);
            background: none;
            border-radius: 0; /* Square border for capture */
        }

        .king-in-checkmate {
            background-color: #ef4444 !important; /* Red for king in checkmate */
        }

        .status-display {
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            min-height: 2rem; /* To prevent layout shift */
        }

        .timer-display {
            font-size: 1.5rem;
            font-weight: 700;
            color: #a7f3d0;
            margin-top: 10px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .control-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .control-group label {
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .control-group input[type="radio"] {
            margin-right: 0.25rem;
        }

        .reset-button {
            background-color: #4299e1; /* Blue */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .reset-button:hover {
            background-color: #3182ce; /* Darker blue on hover */
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-5 bg-gray-900 text-gray-200">
    <div class="game-container bg-gray-800 rounded-2xl p-6 shadow-xl flex flex-col items-center gap-6 w-full">
        <h1 class="text-3xl font-bold text-blue-400 mb-4">Two-Player Chess</h1>

        <div class="controls">
            <div class="control-group">
                <label>Time Control:</label>
                <input type="radio" id="timeControl10Min" name="timeControl" value="10min" checked>
                <label for="timeControl10Min">10 Mins</label>
                <input type="radio" id="timeControlNoControl" name="timeControl" value="nocontrol">
                <label for="timeControlNoControl">No Control</label>
            </div>
            <div class="control-group">
                <label>Board View:</label>
                <input type="radio" id="viewSingle" name="boardView" value="single" checked>
                <label for="viewSingle">Single Board</label>
                <input type="radio" id="viewDouble" name="boardView" value="double">
                <label for="viewDouble">Double Board</label>
            </div>
        </div>

        <div id="status" class="status-display text-lg font-semibold text-center text-gray-100">White to move</div>

        <div class="timer-display-container flex justify-between w-full max-w-lg px-4">
            <div id="whiteTimeDisplay" class="timer-display">10:00</div>
            <div id="blackTimeDisplay" class="timer-display">10:00</div>
        </div>
        
        <div id="boardContainer" class="board-wrapper">
            </div>

        <button id="resetButton" class="reset-button">Reset Game</button>
    </div>

    <script>
        // Initialize Firebase variables (will be populated by the Canvas environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? initialAuthToken : null;

        // Chess board and game state
        let board = [];
        let currentPlayer = 'white'; // 'white' or 'black'
        let selectedPiece = null; // { row, col, piece }
        let possibleMoves = [];
        let isGameOver = false;

        // Timer variables
        let whiteTime = 10 * 60; // 10 minutes in seconds
        let blackTime = 10 * 60;
        let timerInterval;
        let timeControlEnabled = true;
        let boardView = 'single'; // 'single' or 'double'

        // Piece Unicode characters
        const PIECES = {
            'wp': '♙', 'wr': '♖', 'wn': '♘', 'wb': '♗', 'wq': '♕', 'wk': '♔',
            'bp': '♟', 'br': '♜', 'bn': '♞', 'bb': '♝', 'bq': '♛', 'bk': '♚'
        };

        // Initialize Tone.js for sounds
        const moveSound = new Tone.MembraneSynth({
            pitchDecay: 0.005,
            octaves: 3,
            envelope: {
                attack: 0.01,
                decay: 0.3,
                sustain: 0,
                release: 0.2
            }
        }).toDestination();

        const captureSound = new Tone.MetalSynth({
            frequency: 400,
            envelope: {
                attack: 0.001,
                decay: 0.2,
                release: 0.1
            },
            harmonicity: 5.1,
            modulationIndex: 32,
            resonance: 4000,
            octaves: 1.5
        }).toDestination();

        const checkSound = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: {
                attack: 0.005,
                decay: 0.15,
                sustain: 0,
                release: 0.1
            }
        }).toDestination();

        const mateSound = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: 'triangle' },
            envelope: {
                attack: 0.01,
                decay: 0.4,
                sustain: 0,
                release: 0.3
            }
        }).toDestination();

        function playSound(type) {
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            switch (type) {
                case 'move':
                    moveSound.triggerAttackRelease("C3", "32n"); // softer, lower wooden tap
                    break;
                case 'capture':
                    captureSound.triggerAttackRelease("G4", "16n"); // sharper metallic strike
                    break;
                case 'check':
                    checkSound.triggerAttackRelease("A4", "8n"); // subtle error beep
                    break;
                case 'mate':
                    mateSound.triggerAttackRelease(["C4", "E4"], "4n"); // dramatic two-note chord
                    break;
            }
        }

        // --- Timer Functions ---
        function startTimer() {
            stopTimer(); // Clear any existing timer
            if (!timeControlEnabled) {
                document.getElementById('whiteTimeDisplay').textContent = '--:--';
                document.getElementById('blackTimeDisplay').textContent = '--:--';
                return;
            }

            timerInterval = setInterval(() => {
                if (currentPlayer === 'white') {
                    whiteTime--;
                } else {
                    blackTime--;
                }

                updateTimers();

                if (whiteTime <= 0 || blackTime <= 0) {
                    stopTimer();
                    isGameOver = true;
                    const winner = whiteTime <= 0 ? 'Black' : 'White';
                    updateStatus(`${winner} wins by timeout!`);
                    playSound('mate');
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimers() {
            document.getElementById('whiteTimeDisplay').textContent = formatTime(whiteTime);
            document.getElementById('blackTimeDisplay').textContent = formatTime(blackTime);
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        // --- Game Initialization ---
        function initializeBoard() {
            isGameOver = false;
            currentPlayer = 'white';
            selectedPiece = null;
            possibleMoves = [];

            // Get selected time control
            const selectedTimeControl = document.querySelector('input[name="timeControl"]:checked').value;
            timeControlEnabled = (selectedTimeControl === '10min');
            
            if (timeControlEnabled) {
                whiteTime = 10 * 60;
                blackTime = 10 * 60;
            } else {
                whiteTime = 0; // Or a very large number, but 0 indicates 'no control' for display
                blackTime = 0;
            }
            updateTimers(); // Display initial times or '--:--'

            // Get selected board view
            boardView = document.querySelector('input[name="boardView"]:checked').value;


            board = [
                ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
                ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
                ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
            ];
            updateStatus(`${capitalize(currentPlayer)} to move`);
            drawBoard();
            if (timeControlEnabled) {
                startTimer();
            } else {
                stopTimer(); // Ensure timer is stopped if 'No Control' is selected
            }
        }

        // --- Board Drawing ---
        function drawBoard() {
            const boardContainer = document.getElementById('boardContainer');
            boardContainer.innerHTML = ''; // Clear existing boards

            if (boardView === 'single') {
                const chessboardDiv = createChessboardElement('chessboard-single', false);
                boardContainer.appendChild(chessboardDiv);
                renderBoard(chessboardDiv, board, false);
            } else { // double board
                const whiteChessboardDiv = createChessboardElement('chessboard-white', false);
                const blackChessboardDiv = createChessboardElement('chessboard-black', true); // Rotated for black
                
                boardContainer.classList.add('double-board-container'); // Add flex container styling
                boardContainer.appendChild(whiteChessboardDiv);
                boardContainer.appendChild(blackChessboardDiv);

                renderBoard(whiteChessboardDiv, board, false);
                renderBoard(blackChessboardDiv, board, true);
            }
        }

        function createChessboardElement(id, isRotated) {
            const div = document.createElement('div');
            div.id = id;
            div.classList.add('chessboard');
            if (isRotated) {
                div.classList.add('rotated-board');
            }
            return div;
        }

        function renderBoard(targetDiv, currentBoard, isRotated) {
            targetDiv.innerHTML = ''; // Clear existing board in the target div

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');

                    let displayRow = r;
                    let displayCol = c;

                    // Adjust for rotated view if necessary
                    if (isRotated) {
                        displayRow = 7 - r;
                        displayCol = 7 - c;
                    }

                    square.dataset.row = r; // Keep original row/col for logic
                    square.dataset.col = c;

                    // Alternate square colors
                    if ((r + c) % 2 === 0) {
                        square.classList.add('light');
                    } else {
                        square.classList.add('dark');
                    }

                    const piece = currentBoard[r][c];
                    if (piece) {
                        square.textContent = PIECES[piece];
                        const pieceColorClass = piece[0] === 'w' ? 'piece-white' : 'piece-black';
                        square.classList.add(pieceColorClass);
                    }

                    // Add click listener to each square
                    square.addEventListener('click', handleSquareClick);

                    targetDiv.appendChild(square);
                }
            }

            // Apply highlights if any
            if (selectedPiece) {
                const { row, col } = selectedPiece;
                // Highlight on both boards if double view, otherwise just the single one
                const boardsToHighlight = boardView === 'single' ? [document.getElementById('chessboard-single')] : [document.getElementById('chessboard-white'), document.getElementById('chessboard-black')];
                
                boardsToHighlight.forEach(boardElem => {
                    const selectedSquare = boardElem.querySelector(`.square[data-row="${row}"][data-col="${col}"]`);
                    if (selectedSquare) {
                        selectedSquare.classList.add('selected');
                    }
                });
            }

            possibleMoves.forEach(move => {
                const [r, c] = move;
                const boardsToHighlight = boardView === 'single' ? [document.getElementById('chessboard-single')] : [document.getElementById('chessboard-white'), document.getElementById('chessboard-black')];
                
                boardsToHighlight.forEach(boardElem => {
                    const targetSquare = boardElem.querySelector(`.square[data-row="${r}"][data-col="${c}"]`);
                    if (targetSquare) {
                        targetSquare.classList.add('possible-move');
                        if (currentBoard[r][c]) { // If there's a piece, it's a capture move
                            targetSquare.classList.add('capture');
                        }
                    }
                });
            });

            // Highlight king if in check
            const kingColor = currentPlayer === 'white' ? 'wk' : 'bk';
            const kingPosition = findKing(currentBoard, kingColor);
            if (kingPosition && isKingInCheck(currentBoard, currentPlayer)) {
                const [kingR, kingC] = kingPosition;
                const boardsToHighlight = boardView === 'single' ? [document.getElementById('chessboard-single')] : [document.getElementById('chessboard-white'), document.getElementById('chessboard-black')];

                boardsToHighlight.forEach(boardElem => {
                    const kingSquare = boardElem.querySelector(`.square[data-row="${kingR}"][data-col="${kingC}"]`);
                    if (kingSquare) {
                        kingSquare.classList.add('king-in-checkmate');
                    }
                });
            }
        }

        // --- Event Handling ---
        function handleSquareClick(event) {
            if (isGameOver) return;

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            const clickedPiece = board[row][col];

            // If a piece is already selected
            if (selectedPiece) {
                // Check if the clicked square is a valid possible move
                const moveIndex = possibleMoves.findIndex(move => move[0] === row && move[1] === col);
                if (moveIndex !== -1) {
                    // Valid move: make the move
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    selectedPiece = null;
                    possibleMoves = [];
                    drawBoard(); // Redraw after move
                } else {
                    // Clicked on another square, deselect or select new piece
                    selectedPiece = null;
                    possibleMoves = [];
                    drawBoard(); // Clear highlights
                    // If clicked on a piece of the current player, select it
                    if (clickedPiece && clickedPiece[0] === currentPlayer[0]) {
                        selectPiece(row, col, clickedPiece);
                    }
                }
            } else {
                // No piece selected, try to select one
                if (clickedPiece && clickedPiece[0] === currentPlayer[0]) {
                    selectPiece(row, col, clickedPiece);
                }
            }
        }

        function selectPiece(row, col, piece) {
            selectedPiece = { row, col, piece };
            possibleMoves = getLegalMoves(row, col, piece);
            drawBoard(); // Redraw to highlight selected piece and possible moves
        }

        // --- Game Logic ---

        // Function to get all pseudo-legal moves for a piece (doesn't check for king safety)
        function getPseudoLegalMoves(row, col, piece) {
            const moves = [];
            const color = piece[0];
            const type = piece[1];

            switch (type) {
                case 'p': // Pawn
                    const direction = (color === 'w') ? -1 : 1;
                    // Single move
                    if (board[row + direction] && !board[row + direction][col]) {
                        moves.push([row + direction, col]);
                    }
                    // Double move from start
                    if (((color === 'w' && row === 6) || (color === 'b' && row === 1)) &&
                        !board[row + direction][col] && board[row + 2 * direction] && !board[row + 2 * direction][col]) {
                        moves.push([row + 2 * direction, col]);
                    }
                    // Captures
                    if (board[row + direction]) { // Ensure row exists
                        if (col - 1 >= 0 && board[row + direction][col - 1] && board[row + direction][col - 1][0] !== color) {
                            moves.push([row + direction, col - 1]);
                        }
                        if (col + 1 < 8 && board[row + direction][col + 1] && board[row + direction][col + 1][0] !== color) {
                            moves.push([row + direction, col + 1]);
                        }
                    }
                    break;
                case 'r': // Rook
                    // Horizontal and Vertical
                    for (let i = row + 1; i < 8; i++) { if (!addMoveIfValid(moves, i, col, color)) break; }
                    for (let i = row - 1; i >= 0; i--) { if (!addMoveIfValid(moves, i, col, color)) break; }
                    for (let i = col + 1; i < 8; i++) { if (!addMoveIfValid(moves, row, i, color)) break; }
                    for (let i = col - 1; i >= 0; i--) { if (!addMoveIfValid(moves, row, i, color)) break; }
                    break;
                case 'n': // Knight
                    const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    knightMoves.forEach(([dr, dc]) => addMoveIfValid(moves, row + dr, col + dc, color, true));
                    break;
                case 'b': // Bishop
                    // Diagonals
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row + i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row + i, col - i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row - i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row - i, col - i, color)) break; }
                    break;
                case 'q': // Queen
                    // Combines Rook and Bishop moves
                    for (let i = row + 1; i < 8; i++) { if (!addMoveIfValid(moves, i, col, color)) break; }
                    for (let i = row - 1; i >= 0; i--) { if (!addMoveIfValid(moves, i, col, color)) break; }
                    for (let i = col + 1; i < 8; i++) { if (!addMoveIfValid(moves, row, i, color)) break; }
                    for (let i = col - 1; i >= 0; i--) { if (!addMoveIfValid(moves, row, i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row + i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row + i, col - i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row - i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValid(moves, row - i, col - i, color)) break; }
                    break;
                case 'k': // King
                    const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                    kingMoves.forEach(([dr, dc]) => addMoveIfValid(moves, row + dr, col + dc, color, true));
                    break;
            }
            return moves;
        }

        // Helper for sliding pieces (Rook, Bishop, Queen)
        function addMoveIfValid(moves, r, c, color, isSingleMove = false) {
            if (r < 0 || r >= 8 || c < 0 || c >= 8) return false; // Out of bounds

            const targetPiece = board[r][c];
            if (targetPiece && targetPiece[0] === color) {
                return false; // Cannot move to square occupied by own piece
            }
            moves.push([r, c]);
            if (targetPiece && targetPiece[0] !== color) {
                return false; // Captured opponent's piece, stop sliding
            }
            return true; // Continue sliding
        }

        // Function to find the king's position
        function findKing(currentBoard, kingPiece) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === kingPiece) {
                        return [r, c];
                    }
                }
            }
            return null;
        }

        // Function to check if a king is in check on a given board state
        function isKingInCheck(currentBoard, kingColor) {
            const kingPiece = kingColor === 'white' ? 'wk' : 'bk';
            const opponentColor = kingColor === 'white' ? 'b' : 'w';
            const kingPos = findKing(currentBoard, kingPiece);

            if (!kingPos) return false; // Should not happen in a valid game

            const [kingR, kingC] = kingPos;

            // Iterate through all opponent's pieces and check if any can attack the king
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece[0] === opponentColor) {
                        const opponentPseudoMoves = getPseudoLegalMovesForCheck(currentBoard, r, c, piece);
                        for (const move of opponentPseudoMoves) {
                            if (move[0] === kingR && move[1] === kingC) {
                                return true; // King is in check
                            }
                        }
                    }
                }
            }
            return false;
        }

        // A specialized getPseudoLegalMoves that operates on a given board (for check calculations)
        function getPseudoLegalMovesForCheck(currentBoard, row, col, piece) {
            const moves = [];
            const color = piece[0];
            const type = piece[1];

            // Helper for sliding pieces (Rook, Bishop, Queen) for check calculation
            function addMoveIfValidForCheck(movesArr, r, c, pieceColor, isSingleMove = false) {
                if (r < 0 || r >= 8 || c < 0 || c >= 8) return false; // Out of bounds

                const targetPiece = currentBoard[r][c];
                if (targetPiece && targetPiece[0] === pieceColor) {
                    return false; // Cannot move to square occupied by own piece
                }
                movesArr.push([r, c]);
                if (targetPiece && targetPiece[0] !== pieceColor) {
                    return false; // Captured opponent's piece, stop sliding
                }
                return true; // Continue sliding
            }

            switch (type) {
                case 'p': // Pawn
                    const direction = (color === 'w') ? -1 : 1;
                    // Only consider captures for check detection
                    if (currentBoard[row + direction]) {
                        if (col - 1 >= 0 && currentBoard[row + direction][col - 1] && currentBoard[row + direction][col - 1][0] !== color) {
                            moves.push([row + direction, col - 1]);
                        }
                        if (col + 1 < 8 && currentBoard[row + direction][col + 1] && currentBoard[row + direction][col + 1][0] !== color) {
                            moves.push([row + direction, col + 1]);
                        }
                    }
                    break;
                case 'r': // Rook
                    for (let i = row + 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, i, col, color)) break; }
                    for (let i = row - 1; i >= 0; i--) { if (!addMoveIfValidForCheck(moves, i, col, color)) break; }
                    for (let i = col + 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row, i, color)) break; }
                    for (let i = col - 1; i >= 0; i--) { if (!addMoveIfValidForCheck(moves, row, i, color)) break; }
                    break;
                case 'n': // Knight
                    const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                    knightMoves.forEach(([dr, dc]) => addMoveIfValidForCheck(moves, row + dr, col + dc, color, true));
                    break;
                case 'b': // Bishop
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row + i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row + i, col - i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row - i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row - i, col - i, color)) break; }
                    break;
                case 'q': // Queen
                    for (let i = row + 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, i, col, color)) break; }
                    for (let i = row - 1; i >= 0; i--) { if (!addMoveIfValidForCheck(moves, i, col, color)) break; }
                    for (let i = col + 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row, i, color)) break; }
                    for (let i = col - 1; i >= 0; i--) { if (!addMoveIfValidForCheck(moves, row, i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row + i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row + i, col - i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row - i, col + i, color)) break; }
                    for (let i = 1; i < 8; i++) { if (!addMoveIfValidForCheck(moves, row - i, col - i, color)) break; }
                    break;
                case 'k': // King
                    const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                    kingMoves.forEach(([dr, dc]) => addMoveIfValidForCheck(moves, row + dr, col + dc, color, true));
                    break;
            }
            return moves;
        }


        // Function to get all legal moves (considers king safety)
        function getLegalMoves(startRow, startCol, piece) {
            const pseudoLegalMoves = getPseudoLegalMoves(startRow, startCol, piece);
            const legalMoves = [];

            for (const [endR, endC] of pseudoLegalMoves) {
                // Simulate the move
                const tempBoard = JSON.parse(JSON.stringify(board)); // Deep copy
                const capturedPiece = tempBoard[endR][endC];
                tempBoard[endR][endC] = tempBoard[startRow][startCol];
                tempBoard[startRow][startCol] = null;

                // Check if king is in check after the move
                if (!isKingInCheck(tempBoard, currentPlayer)) {
                    legalMoves.push([endR, endC]);
                }
            }
            return legalMoves;
        }

        // Function to execute a move
        function makeMove(startRow, startCol, endRow, endCol) {
            const pieceToMove = board[startRow][startCol];
            const capturedPiece = board[endRow][endCol];

            board[endRow][endCol] = pieceToMove;
            board[startRow][startCol] = null;

            if (capturedPiece) {
                playSound('capture');
            } else {
                playSound('move');
            }

            // Check for pawn promotion (simple: always to queen)
            if (pieceToMove[1] === 'p' && ((currentPlayer === 'white' && endRow === 0) || (currentPlayer === 'black' && endRow === 7))) {
                board[endRow][endCol] = currentPlayer === 'white' ? 'wq' : 'bq';
            }

            // Switch turns
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // Restart timer for the new player
            if (timeControlEnabled) {
                stopTimer();
                startTimer();
            }

            // Check game status after move
            checkGameStatus();
        }

        function checkGameStatus() {
            const playerWhoseTurnItIs = currentPlayer;
            const playerWhoJustMoved = currentPlayer === 'white' ? 'black' : 'white';

            const isPlayerWhoseTurnItIsInCheck = isKingInCheck(board, playerWhoseTurnItIs);

            if (isPlayerWhoseTurnItIsInCheck) {
                playSound('check');
                let hasLegalMoves = false;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece[0] === playerWhoseTurnItIs[0]) {
                            if (getLegalMoves(r, c, piece).length > 0) {
                                hasLegalMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasLegalMoves) break;
                }

                if (!hasLegalMoves) {
                    isGameOver = true;
                    stopTimer();
                    playSound('mate');
                    updateStatus(`${capitalize(playerWhoseTurnItIs)} is checkmated! ${capitalize(playerWhoJustMoved)} wins!`);
                    const kingPieceInCheck = playerWhoseTurnItIs === 'white' ? 'wk' : 'bk';
                    const kingPosition = findKing(board, kingPieceInCheck);
                    if (kingPosition) {
                        const [kingR, kingC] = kingPosition;
                        // Highlight king on both boards if double view
                        const boardsToHighlight = boardView === 'single' ? [document.getElementById('chessboard-single')] : [document.getElementById('chessboard-white'), document.getElementById('chessboard-black')];
                        boardsToHighlight.forEach(boardElem => {
                            const kingSquare = boardElem.querySelector(`.square[data-row="${kingR}"][data-col="${kingC}"]`);
                            if (kingSquare) {
                                kingSquare.classList.add('king-in-checkmate');
                            }
                        });
                    }
                    return;
                } else {
                    updateStatus(`${capitalize(playerWhoseTurnItIs)} is in check! ${capitalize(playerWhoseTurnItIs)} to move.`);
                }
            } else {
                let hasLegalMoves = false;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece[0] === playerWhoseTurnItIs[0]) {
                            if (getLegalMoves(r, c, piece).length > 0) {
                                hasLegalMoves = true;
                                break;
                            }
                        }
                    }
                    if (hasLegalMoves) break;
                }

                if (!hasLegalMoves) {
                    isGameOver = true;
                    stopTimer();
                    updateStatus(`Stalemate! It's a draw.`);
                    return;
                }

                updateStatus(`${capitalize(playerWhoseTurnItIs)} to move`);
            }
        }

        // --- UI Helpers ---
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // --- Event Listeners for Controls ---
        document.getElementById('resetButton').addEventListener('click', initializeBoard);

        document.querySelectorAll('input[name="timeControl"]').forEach(radio => {
            radio.addEventListener('change', initializeBoard); // Re-initialize when time control changes
        });

        document.querySelectorAll('input[name="boardView"]').forEach(radio => {
            radio.addEventListener('change', initializeBoard); // Re-initialize when board view changes
        });

        // --- Initial Setup ---
        window.onload = function() {
            // Start Tone.js audio context on first user interaction
            document.documentElement.addEventListener('mousedown', () => {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
            }, { once: true }); // Only run once

            initializeBoard();
        };

    </script>
</body>
</html>
